# 复习

```
int a[10] = {1,2,3,4,5,6,7};

printf("%d\n", a[0]); //1

a[0] = 10;
a[1] = 20;
printf("%d\n", a[0]); //10

for(int i=0;i<10; i++)
{
	printf("%d ", a[i]); //a[0] a[1] a[2]......a[9]
}
puts("");

for(int i=0; i<10; i++)
{
	scanf("%d", &a[i]);
}

int main()
{
	int i = 10;
	
	for(int i=0;i<10;i++)
	{
		//对于for循环来说，它的局部变量是int i = 0
	}
	
	{
		int i = 20;
	
		printf("%d\n", 20);
	}
	
	printf("%d\n", i); //10
	
}

char buf[10] = "hello";

printf("%c\n", buf[0]); //'h'

buf[0] = 'p';
printf("%c\n", buf[0]); //'p'

puts(buf); //buf是数组的数组名，数组名就是数组的首地址

gets(buf); //报警告

scanf("%s", buf); 

fgets(buf, 10, stdin);
buf[strlen(buf)-1] = '\0'; //消除'\n'

sizeof(buf) = 10;  //10bytes
strlen(buf) = 5;   //5bytes "hello" 

void mystrpy(char *p, const char *q) //const 增加可读性
{
	while(*p++ = *q++);
}

char buf[100] = "worldxxx";

mystrcpy(buf, "hello");


int mystrlen(char *p)
{

}


冒泡排序：

int a[10] = {9,4,5,3,2,5,7,8,4,2};

int temp;

for(int i = 0; i<10; i++)  
{
	for(int j=0; j<9-i; j++) //len-1-i
	{
		if(a[j] > a[j+1]) 
		{
			temp = a[j];
            a[j] = a[j+1];
            a[j+1] = temp;
		}
	}
}

char buf[10] = "nskcjnsko";









作业1：
    mystrcat
    mystrcmp
    mystrstr
    mystrtok








	
```









# 作业



**const + 变量** : 表示变量为只读变量

变量不能被修改 

```c
const int i = 10;  //为了代码的可读性

i = 20; //error



```







**const + 指针**

原则是：修饰谁，谁的内容就不可变，其他的都可变。 

第一种：**const int *p = &a;**

```c++
const 和 int 可以互换位置，二者是等价的。

当把 const 放最前面的时候，它修饰的就是 *p，那么 *p 就不可变。 

这种用法常见于定义函数的形参。前面学习 printf 和 scanf，以及后面将要学习的很多函数，它们的原型中很多参数都是用 const 修饰的，这样做的好处是安全！我们通过参数传递数据时，就把数据暴露了。而大多数情况下只是想使用传过来的数据，并不想改变它的值，但往往由于编程人员个人水平的原因会不小心改变它的值。这时我们在形参中用 const 把传过来的数据定义成只读的，这样就更安全了。这也是 const 最有用之处。  

所以如果你不想改变某个参数传过来的值，那么定义函数时就最好用 const 修饰这个参数，否则就不要用 const 修饰了。  
  
特别要注意的是：
	虽然在 *p 前加上 const 可以禁止指针变量 p 修改变量 a 中的值，但是它只能“禁止指针变量 p 修改”。
  也就是说，它只能保证在使用指针变量 p 时，p 不能修改 a 中的值。
  其他指向 a 的没有用 const 修饰的指针变量照样可以修改 a 的值，而且变量 a 自己也可以修改自己的值。
```

 第二种：**int *const p = &a;**

```c++
这里修饰的是p, 表示指针的指向不能被修改
```

第三种：**const int *const p = &a;**

```c++
const 和 int 可以互换位置，二者是等价的。
此时 *p 和 p 都被修饰了，表示不能通过指针修改指针指向空间的值，同时也不能修改指针的指向
```

eg:

```c++
//正常情况下
//能通过指针修改指针指向空间的值
//指针的指向也能被修改










```



























# 一，数组

## 1 、数组的概念和分类

### 1.1 什么叫数组

​		具有相同类型的一组数据的集合称为数组。通常把这一组数据称为数组的元素。

​		数组在内存中的存储空间一定是连续的。



​		用户自定义的一种数据类型，在内存中连续开辟相同数据类型的空间



### 1.2 分类 

​		在c语言中，数组分为三类：

​		一维数组：具有相同类型的变量的集合称为一维数组。这些变量称为数组的元素。

​		多维数组：具有相同类型的数组的集合称为多维数组。

​		变长数组：在定义数组时，元素个数通过变量来指定，这样的数组称为变长数组。



## 2、一维数组

### 2.1 一维数组定义格式 

格式：元素类型  数组名[元素个数];

​		

```
有很多个int ，很多char类型的数据

数组：
	int a[10];
	char buf[10];

```



### 2.2 一维数组初始化

​	1》完全初始化 -----//给数组中每一个元素赋值

​		例如： 

​			int  a[5] = {1,2,3,4,5};

​			int  a[ ] = {1,2,3,4,5};       //元素个数可以省略

​	   //对于字符型数组：

​		  char str[6] = {'h','e','l','l','l','\0'};

 		 char str[6] = {"hello"};

​		  char str[6] = "hello";		//字符数组初始化的简写形式 ---常用方式

​		  char str[ ] = "hello";		//完全初始化，元素个数可以省略 ---常用方式

​	2》部分初始化 -----//给数组前若干元素赋值

​		int  a[5] = {1,2,3}; 

​		 //对于字符数组：

​		char str[10] = "hello"     //给字符数组部分初始化 ----常用方式

​	3》缺省初始化: 编译器会根据用户初始化的元素个数，给数组开辟足够大的空间大小

​		int a[] = {1,2,3,4,5};
​		a[0] == 1;
​		a[4] == 5;		



### 2.3 一维数组赋值

1》只能单独给每一个元素赋值
2》一般通过循环语句赋值

例如： 

```

数组名+下标  --> 访问数组中的元素

int a[10] = {1,2,3,4,5};

printf("%d\n", a[0]); //数组的下标是从0开始  1

printf("%d\n", a[1]); //2

printf("%d\n", a[4]); //5

a[3] = 100;  //赋值

int i;
for(i=0; i<5; i++)
{
	scanf("%d", &a[i]);
}

```



### 2.4 一维数组打印

非字符数组：循环方式打印每一个元素

字符数组：用%s直接打印

例如： 

```


int a[10] = {0};

char buf[10] = "hello1234";

char buf[10] = {'h', 'e', 'l','l','o'};

char buf[10] = {"hello"};

char buf[10] = "hello"; //√

char buf[] = "hello";  //默认开6个空间,每个空间1Byte

printf("%s\n", buf); //数组名就是数组的首地址

puts(buf); //字符串的输出函数

gets(buf); //字符串的输入函数（不安全）

1. scanf("%s", buf);
2. fgets(buf, 10, stdin);
   buf[strlen(buf)-1] = '\0';  //去掉末尾的'\n'




```







### 2.5 一维数组存储结构(图)











### 2.6 常见的字符函数



```c
strlen:求字符串的真实长度

    char buf[10] = "heloox";
	
	strlen(buf) = 6; 	//不加'\0'
	sizeof(buf) = 10;   //数组占内存的大小 10*1byte = 10Bytes

strcpy
    
	char buf[20] = "xxx";
    
	char str[20] = "yy";
    
	strcpy(buf, str);  //参数必须是地址, buf str都是数组名，首地址
	
	buf --> "yy"
	str --> "yy"
        
    strcpy(buf, "wwwwwww");
	strcpy(str, "ttttttt");
     
	后面的字符串把前面的字符串给替换掉
        

strcat

	char buf[20] = "xxx";
    
	char str[20] = "yy";
    
	strcat(buf, str); 	
     
	buf --> "xxxyy"
    str --> "yy"    
    
    strcat(buf, "ooo");
	strcat(str, "lll");
	
	后面的字符串拼接到前面的字符串的末尾


strcmp
    
	char buf[20] = "xxx";
    
	char str[20] = "xxx";
    
	int n = strcmp(buf, str);  //比较的是ASCII值
    
	n == 0   等于
	n < 0	 小于
    n > 0    大于
    
    strcmp(buf, "tt");  //大于
        
```













## 3、多维数组

### 3.1 多维数组的定义格式

```c
二维数组 ： 一维数组集合   
	一维数组元素数据类型 数组名[二维数组元素个数] [一维数组元素个数] ；

三维数组：  二维数组集合	
	一维数组元素数据类型 数组名[三维数组元素个数] [二维数组元素个数] [一维数组元素个数] ；

.......

n维数组： n-1维数组集合  
    一维数组元素数据类型 数组名[n维数组元素个数]...[二维数组元素个数] [一维数组元素个数] ；

例如： 

二维数组：  int  a[2] [3];          
//a为二维数组，a的元素为a[0]和a[1],
//分别是两个一维数组
//a[0]有三个元素，分别是:a[0] [0],a[0] [1],a[0] [2]    
//a[1]有三个元素，分别是:a[1] [0],a[1] [1],a[1] [2] 

三维数组： int b[2] [3] [4];     
//b为三维数组，元素分别为b[0]和b[1] ,    
//b[0]有三个元素：b[0] [0], b[0] [1], b[0] [2] 
//b[1]有三个元素：b[1] [0], b[1] [1], b[1] [2]  
//其中b[0] [0]为一维数组，有4个元素，
//分别是: b[0] [0] [0] ，b[0] [0] [1]，  b[0] [0] [2]， b[0] [0] [3]

一般来说，多维数组为数组的集合，在多维数组中，二维数组用的比较多，其他更高维数组几乎不用，所以，下面以二维数组为例介绍。
```



### 3.2 二维数组初始化 

```c
一般形式：<数据类型> 数组名[行数][列数];

1》完全初始化 

int  a[2] [3]  = {{1,2,3}，{4,5,6}}；

int  a[ ] [3]  = {{1,2,3}，{4,5,6}}；   

2》部分初始化 

int  b[3] [4] = {{1,2},{3,4}};

```



### 3.3 二维数组赋值

```c
与一维数组类似，二维数组也不能整体赋值，只能分别给每一个元素赋值，例如： 

int a[2] [3];

int i,j;

for( i = 0; i < 2; i++)         //二维数组用两层循环方式赋值

	for(j = 0; j < 3 ;j ++)

		a[i] [j] = i+j+1;
```



### 3.4 二维数组打印

​	只能分别打印每一个元素的值，例如： 

```










```



### 3.5 二维数组存储(图)

![image-20230718161755244](picture/image-20230718161755244.png)













## 4、变长数组

```c
定义：在定义数组时，元素个数通过变量来指定，这样的数组称为变长数组。

例如：

int n,m;

n = 5;

int  a[n];         //a为变长数组

n = 2;  m = 3;

int  b[n] [m];     //b也为变长数组
```

例如： 

```c












总结：

1》变长数组不能初始化

2》在定义变长数组时，变量的值必须确定，且大于0

3》不能把变长数组定义为全局的。
```









# 二，指针



```
前置知识点：

&：取地址符    （取出变量的地址）

*：指针运算符 （取出地址中的值）

指针变量：保存地址的变量



int a = 10;

&a --> 0x789

*(0x789) --> 10

*&a --> 10

* 和 &互为逆运算，互相抵消


int *p;  //说明p是一个指针变量
p = &a;

或者

int *p = &a;


```







## 1、 指针的概念

把用来保存地址的变量称为指针变量，简称指针。



指针就是地址



指针变量 == 指针 == 地址



## 2，指针的定义 

定义格式：  (指针指向的)地址空间中的数据类型  * 指针名;



例如： 

​			int  *p1;       //p1中只能保存int的数据地址，int a;   p1 = &a;

​		    short  *p2;   //p2中只能保存short的数据地址，short b; p2 = &b;



## 3、指针的基本用法

例如： 

​	int  a = 120;

​    int *p = &a;        //等价于：int * p;  p = &a;

将某个数据的地址保存到指针中，通常称为指针指向该数据。

当指针指向某个数据时，对于指针来说，有三个表达式：

*p  --> 120   ------- 表示指针指向的数据

p    --> 0x789 ------ 表示指针本身

&p  地址的地址 ----- 表示指针的地址

```














```



## 4、指针运算

**-------int i=1, j=2, *pi, *pj; --------**



### 4.1  赋值

​		pi = &i; 

​		pj = &j; 

​		左值和右值类型必须要一致，对于指针：左值是指针变量，右值必须时指针指向的数据的地址。



### 4.2  取值

​		*pj;          // *p表示取指针p指向的数据



###  4.3 取地址

​		&p; 					//&p 表示指针在内存空间中的地址。



### 4.4  加法

​	注意：指针只能加一个整数，加法的运算结果与指针的类型有关。

​	例如： 

```










```

 总结：

​	指针加整数n表示指针向高地址方向偏移（n*指针指向的数据类型长度）的字节数。



###  4.5 减法

​	1》指针可以减一个整数	

​	p-1; 

​	p--;

​	总结：指针加整数n表示指针向低地址方向偏移（n*指针指向的数据类型长度）的字节数。



​	2》同类型指针也可以相减

​	pi – pj; 		//表示pi中的地址到pj中的地址之间有多少个指针指向的数据空间大小 

 例如：

```












```



###  4.6 比较

​		注意：必须时同类型的指针，才能比较大小。

​	if(pi > pj)   ------  //表示两个指针中的地址的高低比较





## 5、数组与指针的关系

### 5.1数组名的含义

​		当我们定义一个数组时，计算机会给数组在内存中分配空间

​		此时数组名a：

​		1》代表数组在内存中的空间名称

​		2》代表数组的第一个元素a[0]的地址		

```

一维数组










```

```


二维数据









```

总结：

​		数组的元素可以有多种表示方式，a[i] 等价于 *(a+i)   ,这样的等价表达式，对于指针也适用。





### **5.2数组指针**

定义：指向数组的指针

例如：int (*p)[10];     

​		 p为数值指针

​		int ----表示p指向的数组元素类型为int 

​		10  ---- 表示p指向的数组有10个元素

​		p可以保存数组int a[10]的地址

​		例如：p = &a; 







### **5.3指针数组**

定义：包含指针的数组，数组的元素为指针类型



例如：int *p[10]; 

​		p为数组名，该数组有10个元素，没有元素的类型为 int*









## 6、函数与指针的关系

### **6.1函数指针**

定义：指向函数的指针



在c语言中，每个函数都有一个入口地址，用函数名表示，比如: fun, 也可以用函数名取地址表示，比如：&fun

通常，也可以将函数的入口地址保存到函数指针变量中，然后通过指针变量间接调用函数。



例如：	int (*p)(int);     //定义一个函数指针

​			      |			 |

函数返回值类型   函数的参数类型

上面定义的函数指针只能指向有一个int参数，返回值为int的函数，例如： 

int fun01(int a)							void fun02(int a)                  int fun03(void)

{													{												{

​	..........										...........										............

}													}												}

p = fun01;       //正确				p = fun02;   //错误 				  p = fun03 ;      //错误



### **6.2指针函数**

定义：返回指针的函数



例如：

​		char * p(int a)

​		{

​			char  *p =  "hello world";

​			return p;         //返回值为地址，这样的函数称为指针函数

​		} 

 



### 6.3.函数指针数组 

定义：由函数指针构成的数组，数组元素类型为函数指针的数组 



例如：int (*p[10])(int); 

​	p为数组名

  10 ----- 表示数组p中有10个元素

  int (*)(int) ; --------表示数组的每个元素类型为函数指针，指向有返回值类型为int，且只有一个int参数的函数。

​	

